## 1. Изучить механизм интеропа между языками, попробовать у себя вызывать C/C++ (Не C++/CLI) код (суммы чисел достаточно) из Java и C#. В отчёте описать логику работы, сложности и ограничения этих механизмов.
### Java
Чтобы запустить интероп из java, нам необходимо воспользоваться JNI (Java Native Interface), который предназначен для использования методов других языков в java.
```java
package InteropJNI;

public class JNI
{
    static {
        System.loadLibrary("DllCppSum");
    }
    public native int Summary(int a, int b);
}
```
Далее его компилируем в JNI.class
Теперь обработаем его командой
```
javac -h -cp . InteropJNI\JNI
```
Эта утилита создаст нам файл InteropJNI_JNI.h для нашей программы.
```
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class InteropJNI_JNI */
#ifndef _Included_InteropJNI_JNI
#define _Included_InteropJNI_JNI
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     InteropJNI_JNI
 * Method:    Summary
 * Signature: (II)I
 */
JNIEXPORT jint JNICALL Java_InteropJNI_JNI_Summary
  (JNIEnv *, jobject, jint, jint);

#ifdef __cplusplus
}
#endif
#endif
```
Далее подключаем .h в файл DllCppSum проект. И подключаем его к файлу InteropJNI_JNI.cpp
```cpp
#include "InteropJNI_JNI.h"

JNIEXPORT jint JNICALL Java_InteropJNI_JNI_Summary(JNIEnv* jenv, jobject jobj, int a, int b)
{
	return a + b;
}
```
Билдим его и получаем .dll файл, который успешно отправляется в ...\user\.jdks\openjdk-17.0.2\bin \
После чего можно работать в java с плюсовым кодом.
### C#
Для C# всё по-другому: мы также создаём Dll проект, но достаточно будет просто добавить вконце main.cpp такой код:

```cpp
#include <stdio.h>
int __declspec(dllexport) CppSum (int first, int second)
{
    return a + b;
}
```
И в main.h добавить определение функции:
```cpp
#ifdef __cplusplus
extern "C"
{
#endif
    int __declspec(dllexport) Summary(int first, int second);

#ifdef __cplusplus
}
```
И билдим его. Далее создаём код на C#, предварительно перед каждой функцией добавляя такую инструкцию: 
```cs
[DllImport("DllForCSCppSum.dll", CallingConvention = CallingConvention.Cdecl)]
```
Также не забываем подключить Dll библиотеку 
```cs
using System.Runtime.InteropServices;
```
Осталось разместить сгенерированный .dll в проекте C#. Для этого мы компилируем написанный код, и в той папке, где сгенерировался наш .exe, размещаем .dll \
В моём случае адрес такой: ...\CSForInterop\bin\Debug\net5.0
### Сложности интеропа:
Много лишних дополнительных действий (генерация .h и .dll) \
Необходимость переименовывания оригинальных методов на интеропящемся языке. \
При небольшом изменении используемого кода необходимо заново перегенерировывать .dll файл

## 2. Написать немного кода на Scala и F# с использованием уникальных возможностей языка - Pipe operator, Discriminated Union, Computation expressions и т.д. . Вызвать написанный код из обычных соответствующих ООП языков (Java и С#) и посмотреть во что превращается написанный раннее код после декомпиляции в них. 
Процесс декомпиляции в C# происходил на сайте: https://sharplab.io \
Процесс декомпиляции для Java происходил в приложении IntelliJ IDEA \
### Pipe operator
Оператор конвейера, который передает результат выполнения выражения первым параметром в другое выражение. \
В Scala необходимо импортировать библиотеку для его использования
```Scala
import scala.util.chaining.scalaUtilChainingOps
```
Я использовал этот оператор в функции нахождения дисперсии, объединив таким образом множество функций:
```Scala
def dispersion(array: Array[Double]): Double = {
    diff(array, array.pipe(avg)).pipe(squares).pipe(avg)
  }
```
Этот код декомпилировался в нечто такое:
```java
public double dispersion(final double[] array) {
      return BoxesRunTime.unboxToDouble(scala.util.ChainingOps..MODULE$.pipe$extension(scala.util.package.chaining..MODULE$.scalaUtilChainingOps(scala.util.ChainingOps..MODULE$.pipe$extension(scala.util.package.chaining..MODULE$.scalaUtilChainingOps(this.diff(array, BoxesRunTime.unboxToDouble(scala.util.ChainingOps..MODULE$.pipe$extension(scala.util.package.chaining..MODULE$.scalaUtilChainingOps(array), (arrayx) -> {
         return BoxesRunTime.boxToDouble($anonfun$dispersion$1(arrayx));
      })))), (arrayx) -> {
         return MODULE$.squares(arrayx);
      })), (arrayx) -> {
         return BoxesRunTime.boxToDouble($anonfun$dispersion$3(arrayx));
      }));
   }
```
Что впринципе логично, потому что Scala функциональный язык и многие короткозаписывающиеся фишки этого языка тяжело перенимаются java'ой. \
Это единственный метод, который я реализовал на Scala, т.к. перечисленные в задании фишки в основном существуют на C# и едва ли реализованы на Scala. \
В F# Pipe operator вызывается такой парой символов: |>
```fs
module FSProject.PipeOperator
[| 1 .. 10 |]
|> Array.filter (fun elem -> elem % 2 = 0)
|> Array.choose (fun elem -> if (elem <> 8) then Some(elem*elem) else None)
|> Array.rev
|> printfn "%A"
```
После декомпиляции этот маленький на вид код превратился в огромный 97-строчный. Всё из-за нетривиальности процессов, которые происходят в pipe в общем виде. Потому что только 3 строчки заняты реализацией написанного кода, а всё остальное является просто подключением всех библиотек и настройкой классов, которые отвечают за вывод в консоль и pipe operator и прочие сложные функции. В общем, переход очевидно увеличил код, ведь F# как раз-таки и нужен для быстрой бестиповой функциональной реализации кодов.
### Discriminated Union
Конструкция, позволяющая создать тип-сумму или тип-произведение (второе аналогично кортежам).
```fs
module FSProject.DiscriminatedUnion
open System

type Product =
    | Fruit of String * Double
    | Vegetable of String * Double
    | Sweet of String * Double
    
type Figure =
    | Circle of Double
    | Rectangle of Int32 * Int32
    
type Box = {
    product : Product;
    quantity : Int32;
    form : Figure;
}

let box1 = {
    product = Fruit("apple", 6.138);
    quantity = 300;
    form = Circle(1.58);
}

let box2 = {box1 with quantity = 200;}
```
При декомпиляции получилось 1624 строки, что оставляет невозможным разобраться в этом, но основная суть кода это классы и наследования от классов, что способствует собрать описанные типы. \
Объявление переменных получилось весьма коротким:
```cs
        static DiscriminatedUnion()
        {
            box1@19 = new FSProject.DiscriminatedUnion.Box(FSProject.DiscriminatedUnion.Product.NewFruit("apple", 6.138), 300, FSProject.DiscriminatedUnion.Figure.NewCircle(1.58));
            box2@25 = new FSProject.DiscriminatedUnion.Box(FSProject.DiscriminatedUnion.box1.product@, 200, FSProject.DiscriminatedUnion.box1.form@);
        }
    }
}
```
### Computation expressions
Классы-билдеры, переопределяющие ключевые слова и реализующие конструкции привязок потока управления. \
Рассмотрим пример с выражением yield:
```fs
module FSProject.ComputationalExpressions

open System

let rec fib (e1, e2) = seq{
    yield e1
    yield! fib (e2, e1 + e2)
}

fib (0, 1) |> Seq.take 10 |> Seq.iter Console.WriteLine
```
Перекочуем в C#. И получим 142 строки C#-кода, где реализован класс ComputationalExpressions c определением внутри него функции fib. \
В функции ComputationalExpressions() описывается обработка последовательности.
```cs
static ComputationalExpressions()
        {
            SeqModule.Iterate(FSProject.ComputationalExpressions.clo@10.@_instance, SeqModule.Take(10, FSProject.ComputationalExpressions.fib(0, 1)));
        }
```
### Вызвать написанный код из обычных соответствующих ООП языков (Java и С#).
Проблем с использованием прописанного кода на соответствующих языках не возникло.
Единственное, что могу сказать, это то, что для C# требуется создавать новый проект, который может обращаться к F#, предварительно добавляя ссылку на F# Project.
Ссылка добавляется путём нажатия правой кнопки мыши на поле класса в Rider, далее Add и Add Reference...

## 3. Написать алгоритм обхода графа (DFS и BFS) на языке Java, собрать в пакет и опубликовать (хоть в Maven, хоть в Gradle, не имеет значения). Использовать в другом проекте на Java/Scala этот пакет. Повторить это с C#/F#. В отчёте написать про алгоритм работы пакетных менеджеров, особенности их работы в C# и Java мирах.
### Реализация алгоритма на Java:
```java
import java.util.*;

public class Graph {
    private int n;
    private List<List<Integer>> graph;

    public Graph(int n) {
        this.n = n;
        graph = new ArrayList<>(n);
    }

    public void addEdge(int from, int to) {
        graph.get(from).add(to);
    }

    public boolean[] bfs(int vertex) {
        boolean[] isVisited = new boolean[n];
        Queue queue = new LinkedList();
        queue.add(vertex);
        while(!queue.isEmpty()) {
            int node = (int)queue.remove();
            isVisited[node] = true;
            for (int neighbour: graph.get(vertex)) {
                if (!isVisited[neighbour])
                    queue.add(neighbour);
            }
        }
        return isVisited;
    }

    public boolean[] dfs(int vertex) {
        boolean[] isVisited = new boolean[n];
        dfsRecursive(vertex, isVisited);
        return isVisited;
    }

    private void dfsRecursive(int vertex, boolean[] isVisited) {
        for (int neighbour: graph.get(vertex)) {
            if (!isVisited[neighbour])
                dfsRecursive(neighbour, isVisited);
        }
    }
}
```
Заранее подготовим Main.java с методом main для генерации .jar, расположив его в одной папке с Graph.java
```java
public class Main {
    public static void main(String[] args) {
        
    }
}
```
Создадим Maven-проект и запакетируем библиотеку в jar-файл при помощи раздела File -> ProjectStructure -> Artifacts -> Add(+) -> JAR -> From modules with dependencies. Далее билдим созданный артифакт. Полученный jar должен лежать в директории out. \
Создаём новый проект, причём building system этого проекта влияет на метод импорта пакета. Например, если этот проект обычный и собирается через IntelliJ, то будет достаточно зайти в File -> ProjectStructure -> Modules и добавить зависимость, выбрав путь к .jar \
Если же проект создан через Maven, то придётся помимо всего этого добавить ещё зависимости в pom.xml и прописать 3 команды в cmd:
```cmd
mvn install:install-file -Dfile=<path-to-file> -DgroupId=<group-id> -DartifactId=<artifact-id> -Dversion=<version> -Dpackaging=<packaging>
mvn install:install-file -Dfile=<path-to-file> -DpomFile=<path-to-pomfile>
mvn org.apache.maven.plugins:maven-install-plugin:2.5.2:install-file -Dfile=<path-to-file>
```
После этого мы можем даже не импортить этот пакет, а сразу использовать его классы.
### Реализация алгоритма на C#:
```cs
namespace CSGraph;

public class Graph
{
    private int _n;
    private readonly List<List<int>> _graph;

    public Graph(int n)
    {
        _n = n;
        _graph = new List<List<int>>(n);
    }
    
    public void AddEdge(int from, int to) {
        _graph[from].Add(to);
    }

    public bool[] Bfs(int vertex) {
        var isVisited = new bool[_n];
        var queue = new Queue<int>();
        queue.Enqueue(vertex);
        while(queue.Count > 0) {
            var node = queue.Peek();
            queue.Dequeue();
            isVisited[node] = true;
            foreach (var neighbour in _graph[vertex].Where(neighbour => !isVisited[neighbour]))
            {
                queue.Enqueue(neighbour);
            }
        }
        return isVisited;
    }

    public bool[] Dfs(int vertex) {
        var isVisited = new bool[_n];
        DfsRecursive(vertex, isVisited);
        return isVisited;
    }

    private void DfsRecursive(int vertex, IReadOnlyList<bool> isVisited)
    {
        foreach (var neighbour in _graph[vertex].Where(neighbour => !isVisited[neighbour]))
        {
            DfsRecursive(neighbour, isVisited);
        }
    }
}
```
В C# необходимо нажать ПКМ на проект и выбрать Properties > NuGet, где мы можем настроить всю информацию о будущем пакете. \
Далее в cmd переходим в папку проекта и пишем: dotnet pack \
Должен сформироваться файл ./bin/Debug/CSGraph.1.0.0.nupkg \
Снизу находим NuGet -> Sources -> Feeds, где добавляем New feed с полным путём до папки Debug.
Далее мы создаём новый проект, заходим в NuGet -> Packages, и скачиваем выложенный пакет.

## 4. Изучить инструменты для оценки производительности в C# и Java. Написать несколько алгоритмов сортировок (и взять стандартную) и запустить бенчмарки (в бенчмарках помимо времени выполнения проверить аллокации памяти). В отчёт написать про инструменты для бенчмаркинга, их особености, анализ результатов проверок.
### С#
В C# есть библиотека BenchmarkDotNet, которую необходимо использовать для анализа работы.
Sorter.cs
```cs
namespace CSSorter;

public class Sorter
{
    public static void bubbleSort(List<int> list) {
        for (int i = 0; i < list.Count; i++) {
            for (int j = i; j < list.Count; j++) {
                if (list[i] > list[j]) {
                    swap(list[i], list[j]);
                }
            }
        }
    }

    public static void mergeSort(List<int> list, int l, int r) {
        if (list.Count <= r || l >= r) return;
        int m = (l + r) / 2;
        mergeSort(list, l, m);
        mergeSort(list, m + 1, r);
        var newList = new List<int>();
        for (int i = l, j = m + 1; i <= m || j <= r; ) {
            if (i == m+1) newList.Add(list[j++]);
            else if (j == r+1) newList.Add(list[i++]);
            else if (list[j] < list[i]) newList.Add(list[j++]);
            else newList.Add(list[i++]);;
        }

        for (int i = 0; i < newList.Count; i++)
            list[l + i] = newList[i];
    }

    public static void standardSort(List<int> list) {
        list.Sort();
    }

    private static void swap(int a, int b) {
        int t = a;
        a = b;
        b = t;
    }
}
```
BenchmarkSorter.cs
```cs
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Order;
namespace CSSorter;

[MemoryDiagnoser]
[Orderer(SummaryOrderPolicy.FastestToSlowest)]
[RankColumn]
public class BenchmarkSorter
{
    private List<int> _list;

    public BenchmarkSorter()
    {
        var random = new Random();
        const int n = 10000;
        _list = new List<int>();
        for (var i = 0; i < n; i++)
        {
            _list.Add(random.Next());
        }
    }

    [Benchmark]
    public void bubbleSort()
    {
        var list = new List<int>(_list);
        Sorter.bubbleSort(list);
    }
    
    [Benchmark]
    public void mergeSort()
    {
        var list = new List<int>(_list);
        Sorter.mergeSort(list, 0, list.Count - 1);
    }

    [Benchmark]
    public void standardSort()
    {
        var list = new List<int>(_list);
        Sorter.standardSort(list);
    }
}
```
Соберём проект (перейдём в папку с проектом в cmd и запустим dotnet build -c Release). \
Далее запустим сгенерированный .dll, запустив тем самым описанный benchmark (dotnet bin\Release\net6.0\CSSorter.dll)
|       Method |       Mean |     Error |    StdDev | Rank |      Gen0 |    Gen1 |  Allocated |
|------------- |-----------:|----------:|----------:|-----:|----------:|--------:|-----------:|
| standardSort |   1.250 ms | 0.0133 ms | 0.0118 ms |    1 |   37.1094 |       - |   39.12 KB |
|    mergeSort |   9.223 ms | 0.1248 ms | 0.1167 ms |    2 | 2171.8750 | 62.5000 | 2328.76 KB |
|   bubbleSort | 585.546 ms | 4.7382 ms | 4.4322 ms |    3 |         - |       - |   39.59 KB |

### Java
Чтобы провести диагностику ресурсов в Java, необходимо в pom.xml с помощью dependencies описать зависимости с плагином JMH.
```xml
<dependencies>
    <dependency>
        <groupId>org.openjdk.jmh</groupId>
        <artifactId>jmh-core</artifactId>
        <version>1.33</version>
    </dependency>
    <dependency>
        <groupId>org.openjdk.jmh</groupId>
        <artifactId>jmh-generator-annprocess</artifactId>
        <version>1.33</version>
    </dependency>
</dependencies>
```
Далее делаем Maven -> Reload Project и наши зависимости определяются. \
Пропишем классы и запустим Benchmark. \
Sorter.java
```java
package org.example;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Sorter {

    public static void bubbleSort(List<Integer> list) {
        for (int i = 0; i < list.size(); i++) {
            for (int j = i; j < list.size(); j++) {
                if (list.get(i) > list.get(j)) {
                    Integer t = list.get(i);
                    list.set(i, list.get(j));
                    list.set(j, t);
                }
            }
        }
    }

    public static void mergeSort(List<Integer> list, int l, int r) {
        if (list.size() <= r || l >= r) return;
        int m = (l + r) / 2;
        mergeSort(list, l, m);
        mergeSort(list, m + 1, r);
        List<Integer> newList = new ArrayList<>();
        for (int i = l, j = m + 1; i <= m || j <= r; ) {
            if (i == m + 1) newList.add(list.get(j++));
            else if (j == r + 1) newList.add(list.get(i++));
            else if (list.get(j) < list.get(i)) newList.add(list.get(j++));
            else newList.add(list.get(i++));
        }

        for (int i = 0; i < newList.size(); i++)
            list.set(l + i, newList.get(i));
    }

    public static void standardSort(List<Integer> list) {
        Collections.sort(list);
    }
}
```
BenchmarkSorter.java
```java
package org.example;

import org.openjdk.jmh.annotations.*;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

@State(Scope.Benchmark)
@Fork(value = 1)
@Warmup(iterations = 2)
@Measurement(iterations = 2)
@BenchmarkMode(Mode.All)
public class BenchmarkSorter
{
    private List<Integer> list;

    @Setup
    public void setUp() {
        var random = new Random();
        int n = 10000;
        list = new ArrayList<Integer>();
        for (var i = 0; i < n; i++)
        {
            list.add(random.nextInt());
        }
    }

    @Benchmark
    public void bubbleSort() {
        var newList = new ArrayList<Integer>(list);
        Sorter.bubbleSort(newList);
    }

    @Benchmark
    public void mergeSort() {
        var newList = new ArrayList<Integer>(list);
        Sorter.mergeSort(newList, 0, newList.size() - 1);
    }

    @Benchmark
    public void standardSort() {
        var newList = new ArrayList<Integer>(list);
        Sorter.standardSort(list);
    }
}
```
Main.java
```java
package org.example;

public class Main {
    public static void main(String[] args) {
    }
}
```
|    Benchmark                 |       Mode |     Cnt   |    Score  |     Units |
|----------------------------- |-----------:|----------:|----------:|----------:|
| BenchmarkSorter.bubbleSort   |   thrpt    |     2     |     0,571 |  ops/s    |
| BenchmarkSorter.mergeSort    |   thrpt    |  2        |    85,662 |  ops/s    |
| BenchmarkSorter.standardSort |   thrpt    |  2        |  9992,802 |  ops/s    |
| BenchmarkSorter.bubbleSort   |   avgt     |  2        |     1,755 |  s/op     |
| BenchmarkSorter.mergeSort    |   avgt     |  2        |     0,012 |  s/op     |
| BenchmarkSorter.standardSort |   avgt     |  2        |    ≈ 10⁻⁴ |  s/op     |

## 5. Используя инструменты dotTrace, dotMemory, всё-что-угодно-хоть-windbg, проанализировать работу написанного кода для бекапов. Необходимо написать сценарий, когда в цикле будет выполняться много запусков, будут создаваться и удаляться точки. Проверить два сценария: с реальной работой с файловой системой и без неё. В отчёте неоходимо проанализировать полученные результаты, сделать вывод о написанном коде. Опционально: предложить варианты по модернизации или написать альтернативную имплементацию.
Для анализа работы создадим проект, который запустим в JetBrains DotMemory. Перед этим запакетируем 3 лабу по ООП (бэкапы) и откроем её в новом проекте. \
Опишем такой класс:
```cs
using Backups.Services;
using Backups.Tools.Repository;
using Backups.Tools.StorageAlgorithm;

namespace BackUpsAnalyser
{
    internal static class Program
    {
        private static void Main()
        {
            var dataStorage = Path.Combine(
                Path.Combine(
                    Directory.GetParent(Directory.GetCurrentDirectory())?
                        .Parent?
                        .FullName!),
                "Data");
            while (true)
            {
                var service = new BackUpJob(new AbstractFileSystem(), new SingleStorage(), "BackUp");
                service.AddJobObject("C:\\Users\\Татьяна\\Desktop\\учёба\\Программирование\\4 сем - Техи\\1 laba\\5task\\picture1.bmp");
                service.AddJobObject("C:\\Users\\Татьяна\\Desktop\\учёба\\Программирование\\4 сем - Техи\\1 laba\\5task\\picture2.bmp");
                service.AddJobObject("C:\\Users\\Татьяна\\Desktop\\учёба\\Программирование\\4 сем - Техи\\1 laba\\5task\\picture3.bmp");
                service.MakeRestorePoint();
                service.MakeRestorePoint();
                service.MakeRestorePoint();
                service.MakeRestorePoint();
               // Directory.Delete(Path.Combine(dataStorage, "BackUp"), true);
            }
        }
    }
}
```
Далее забилдим проект, скачаем приложение DotMemory и занесём туда .exe из папки bin \
После протестим для настоящей ФС и для фейковой и сравним результаты.
[Local file system](https://github.com/is-tech-y24-1/jizapika/blob/lab-1/изображение_2022-09-14_015251113.png)

![](https://github.com/is-tech-y24-1/jizapika/blob/lab-1/изображение_2022-09-14_015251113.png)

- [Abstract file system](https://github.com/is-tech-y24-1/jizapika/blob/lab-1/изображение_2022-09-14_015707049.png)

![](https://github.com/is-tech-y24-1/jizapika/blob/lab-1/изображение_2022-09-14_015707049.png)

Зубчики получаются, потому что память периодически подчищается и сборщик мусора удаляет объекты, на которые никто не ссылается. \
У абстрактной зубчики узже, потому что проходит меньше времени на выделение критической памяти, т.к. не требуется нагружать и перетаскивать реальные файлы, то есть всё время работы затрачено на выделение памяти в пределах программы.
